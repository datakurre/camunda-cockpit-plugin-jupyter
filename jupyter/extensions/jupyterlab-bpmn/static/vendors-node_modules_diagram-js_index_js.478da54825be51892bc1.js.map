{"version":3,"file":"vendors-node_modules_diagram-js_index_js.478da54825be51892bc1.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAgC;;AAEA;;;AAGhC;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA,YAAY,eAAe;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,qBAAqB,0CAAQ;;AAE7B;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gCAAgC,0CAAU;;AAE1C;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uBAAuB,cAAc;AACrC,IAAI;AACJ;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,WAAW,eAAe;AAC1B;AACe;;AAEf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD,MAAM;AACN;AACA,YAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AClMkB;;AAKW;;AAKH;;AAEoB;;AAQ5B;;AAEsC;;;AAGxD;AACA;AACA;;AAEA;AACA,SAAS,kDAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,aAAa;AACzB;AACA;;AAEA,YAAY,gDAAM,GAAG,IAAI,+BAA+B;;AAExD;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAE,gDAAM;AACR;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA,cAAc,gDAAS;AACvB,EAAE,iDAAU;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B;AACe;;AAEf;AACA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc,WAAW,eAAe;AACvF;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,gDAAS;AACjC,EAAE,8CAAO,QAAQ,+BAA+B;;AAEhD,EAAE,gDAAS;;AAEX;;AAEA;;AAEA;AACA;AACA;AACA,2BAA2B,kDAAQ,CAAC,8CAAI;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kBAAkB,YAAY;AAC9B,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,KAAK;;AAEL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,eAAe,uDAAO;;AAEtB;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ,wBAAwB;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,gDAAM;AACzB;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE,iDAAO;AACT;;AAEA;AACA;AACA,QAAQ,iDAAU;AAClB,QAAQ;AACR,QAAQ,iDAAU;AAClB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,YAAY;AACZ,gBAAgB,mBAAmB;AACnC,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,SAAS;AACzB;AACA,iDAAiD,kEAAkE;AACnH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW,uBAAuB;AAClC,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS,iDAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,oCAAoC;AAC9D;;AAEA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,SAAS;AACpB;AACA,YAAY,uBAAuB;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,sBAAsB;AACzD,oCAAoC,sBAAsB;;AAE1D;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,kBAAkB;;AAElD;;AAEA,kCAAkC,4BAA4B;AAC9D;;AAEA;;AAEA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,cAAc,+CAAK;AACnB;AACA,GAAG;;AAEH;AACA;AACA,qBAAqB,mCAAmC;AACxD;AACA;;AAEA;AACA,EAAE,sDAAa;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAK;AACb,QAAQ,KAAK;AACb;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,uBAAuB;AAClC,WAAW,uBAAuB;AAClC,WAAW,QAAQ;AACnB;AACA,YAAY,uBAAuB;AACnC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,iCAAiC,kCAAkC;;AAEnE;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,mCAAmC,4BAA4B;;AAE/D;AACA;;AAEA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,oCAAoC,kBAAkB;;AAEtD;;AAEA;AACA,EAAE,yDAAgB;AAClB;;AAEA,qCAAqC,kBAAkB;;AAEvD;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA,YAAY,iBAAiB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,gBAAgB,iBAAiB;AACjC,gBAAgB,QAAQ;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,gBAAgB,iBAAiB;AACjC,gBAAgB,QAAQ;AACxB;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA,YAAY,sBAAsB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,gBAAgB,sBAAsB;AACtC,gBAAgB,QAAQ;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,gBAAgB,sBAAsB;AACtC,gBAAgB,QAAQ;AACxB;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,SAAS;AACpB;AACA,YAAY;AACZ;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA,kDAAkD,yBAAyB;AAC3E;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,mDAAY;AAC5B,4CAA4C,sDAAY;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA,MAAM,mDAAY;AAClB,KAAK;AACL;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,gDAAM,GAAG,cAAc,aAAa;;AAElD;;AAEA;AACA,KAAK;AACL;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,uDAAc;AACpC,oBAAoB,0DAAM;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,0DAAM;;AAE1B;;AAEA;;AAEA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,gBAAgB,gCAAgC;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA,WAAW,cAAc,+BAA+B,cAAc;AACtE;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,kBAAkB,gDAAM;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACnmCA;;AAE2C;;;AAG3C;AACA;AACA;AACA;AACA;AACe;AACf;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;;AAEA;;AAEA;;AAEA;AACA,EAAE,8CAAO;;AAET;AACA,IAAI,8CAAO;AACX;;AAEA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI,8CAAO;;AAEX;AACA,MAAM,8CAAO;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,mBAAmB,8CAAO;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,mCAAmC,WAAW;AAC9C;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,mDAAmD;AACnD;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,SAAS;AACpB;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7NkB;;AAElB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB,KAAK;AACvD,oCAAoC,oBAAoB;AACxD,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACe;AACf;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;;AAEA,WAAW,iDAAO;;AAElB,MAAM,oDAAU;AAChB;AACA;AACA;AACA;;AAEA,OAAO,kDAAQ;AACf;AACA;;AAEA;;AAEA;AACA,qBAAqB,8CAAI;;AAEzB;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;AAGA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA,MAAM,oDAAU;AAChB;AACA;AACA;AACA;;AAEA,OAAO,kDAAQ;AACf;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,0BAA0B,YAAY;AACtC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,UAAU;AACrB;AACA;;AAEA,WAAW,iDAAO;;AAElB;;AAEA;AACA;AACA,GAAG;;AAEH;;;AAGA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,iBAAiB,aAAa;AAC9B;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,8BAA8B,cAAc;AAC5C;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ,WAAW;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE,gDAAM,iBAAiB;AACzB;;;AAGA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,eAAe;AAC1B;AACA,YAAY;AACZ;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrgBkB;;AAKY;;AAEuB;;AAET;;AAQ1B;;AAIQ;;AAE1B;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,iBAAiB;AAC5B;AACe;AACf;AACA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,kBAAkB,+DAAW;AAC7B;AACA,oBAAoB,gDAAS;AAC7B,MAAM,iDAAU;;AAEhB,MAAM,gDAAS;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAS;;AAExB,EAAE,8CAAQ;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,iBAAiB,gDAAS;AAC1B,EAAE,iDAAU;;AAEZ;AACA;AACA;AACA,IAAI;AACJ,IAAI,gDAAS;AACb;;AAEA,YAAY,gDAAS;AACrB,EAAE,iDAAU;AACZ,EAAE,iDAAU;;AAEZ;AACA,IAAI,iDAAU;AACd;;AAEA,EAAE,gDAAS;;AAEX;AACA,eAAe,gDAAS;AACxB,EAAE,iDAAU;;AAEZ,EAAE,gDAAS;;AAEX;AACA;;AAEA;AACA;AACA,+DAA+D,8DAAc;AAC7E;;AAEA;;AAEA;AACA;AACA;;AAEA,YAAY,gDAAM;;AAElB;AACA;AACA;;AAEA;AACA,GAAG,IAAI;;AAEP;AACA;AACA,EAAE,iDAAO;;AAET;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAI,iDAAO;AACX;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;AAEA,yCAAyC,+BAA+B;AACxE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,8CAA8C,+BAA+B;AAC7E;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,iEAAS;AACb,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,IAAI,8CAAO;AACX,IAAI;AACJ,IAAI,8CAAO;AACX;AACA;;AAEA;AACA;;AAEA;AACA,EAAE,gDAAS;AACX;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;ACtPiC;;AAEH;AACkB;AACF;AACZ;AACc;;AAEhD,iEAAe;AACf,iBAAiB,0CAAU;AAC3B;AACA,oBAAoB,4CAAM;AAC1B,6BAA6B,qDAAe;AAC5C,4BAA4B,oDAAc;AAC1C,sBAAsB,8CAAQ;AAC9B,6BAA6B,qDAAe;AAC5C,CAAC;;;;;;;;;;;;;;;;;;;;AChB+B;;AAEU;;AAKd;;AAMV;;AAIQ;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACe;;AAEf;AACA,EAAE,uDAAiB;;AAEnB,wDAAwD,mCAAmC;AAC3F,oCAAoC,kDAAkD;AACtF,mDAAmD,uDAAuD;AAC1G;;AAEA,+CAAQ,kBAAkB,kDAAY;;;AAGtC;AACA;AACA;;AAEA;AACA,aAAa,gDAAS;;AAEtB,EAAE,8CAAO;AACT;AACA;AACA;AACA;AACA,GAAG;;AAEH,MAAM,8DAAc;AACpB,IAAI,8CAAO;AACX,IAAI;AACJ,IAAI,8CAAO;AACX;;AAEA,EAAE,gDAAS;;AAEX;AACA;;AAEA;;AAEA,aAAa,4DAAU;AACvB,EAAE,gDAAS;;AAEX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,kEAAgB;AACzB;;AAEA;AACA;;AAEA;;AAEA,gBAAgB,0BAA0B;;AAE1C;AACA;AACA;;AAEA;AACA;;AAEA,SAAS,kEAAgB;AACzB;;;AAGA;;;;;;;;;;;;;;;;AC3GkB;;;AAGlB;AACA;AACA;AACe;;AAEf;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA;AACA;;AAEA,WAAW,gDAAM,UAAU,oBAAoB;AAC/C;;AAEA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA,SAAS,iDAAO;AAChB;AACA;AACA;;AAEA,gBAAgB,gDAAM;AACtB,aAAa,gDAAM,8BAA8B;AACjD,KAAK,IAAI;;AAET,6BAA6B,gDAAM;AACnC;;AAEA;AACA,SAAS,iDAAO;AAChB;AACA;AACA;;AAEA,oCAAoC,gDAAM,GAAG,6BAA6B;AAC1E;AACA;;;;;;;;;;;;;;;;;ACxEgD;AAClB;;AAE9B,iEAAe;AACf;AACA,6BAA6B,qDAAe;AAC5C,oBAAoB,4CAAM;AAC1B,CAAC,EAAC;;;;;;;;;;;;;;;;;;ACPF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEwD","sources":["webpack://jupyterlab-bpmn/./node_modules/diagram-js/index.js","webpack://jupyterlab-bpmn/./node_modules/diagram-js/lib/Diagram.js","webpack://jupyterlab-bpmn/./node_modules/diagram-js/lib/core/Canvas.js","webpack://jupyterlab-bpmn/./node_modules/diagram-js/lib/core/ElementRegistry.js","webpack://jupyterlab-bpmn/./node_modules/diagram-js/lib/core/EventBus.js","webpack://jupyterlab-bpmn/./node_modules/diagram-js/lib/core/GraphicsFactory.js","webpack://jupyterlab-bpmn/./node_modules/diagram-js/lib/core/index.js","webpack://jupyterlab-bpmn/./node_modules/diagram-js/lib/draw/DefaultRenderer.js","webpack://jupyterlab-bpmn/./node_modules/diagram-js/lib/draw/Styles.js","webpack://jupyterlab-bpmn/./node_modules/diagram-js/lib/draw/index.js","webpack://jupyterlab-bpmn/./node_modules/didi/dist/index.esm.js"],"sourcesContent":["export { default } from './lib/Diagram';","import { Injector } from 'didi';\n\nimport CoreModule from './core';\n\n\n/**\n * Bootstrap an injector from a list of modules, instantiating a number of default components\n *\n * @ignore\n * @param {Array<didi.Module>} bootstrapModules\n *\n * @return {didi.Injector} a injector to use to access the components\n */\nfunction bootstrap(bootstrapModules) {\n\n  var modules = [],\n      components = [];\n\n  function hasModule(m) {\n    return modules.indexOf(m) >= 0;\n  }\n\n  function addModule(m) {\n    modules.push(m);\n  }\n\n  function visit(m) {\n    if (hasModule(m)) {\n      return;\n    }\n\n    (m.__depends__ || []).forEach(visit);\n\n    if (hasModule(m)) {\n      return;\n    }\n\n    addModule(m);\n\n    (m.__init__ || []).forEach(function(c) {\n      components.push(c);\n    });\n  }\n\n  bootstrapModules.forEach(visit);\n\n  var injector = new Injector(modules);\n\n  components.forEach(function(c) {\n\n    try {\n\n      // eagerly resolve component (fn or string)\n      injector[typeof c === 'string' ? 'get' : 'invoke'](c);\n    } catch (e) {\n      console.error('Failed to instantiate component');\n      console.error(e.stack);\n\n      throw e;\n    }\n  });\n\n  return injector;\n}\n\n/**\n * Creates an injector from passed options.\n *\n * @ignore\n * @param  {Object} options\n * @return {didi.Injector}\n */\nfunction createInjector(options) {\n\n  options = options || {};\n\n  var configModule = {\n    'config': ['value', options]\n  };\n\n  var modules = [ configModule, CoreModule ].concat(options.modules || []);\n\n  return bootstrap(modules);\n}\n\n\n/**\n * The main diagram-js entry point that bootstraps the diagram with the given\n * configuration.\n *\n * To register extensions with the diagram, pass them as Array<didi.Module> to the constructor.\n *\n * @class djs.Diagram\n * @memberOf djs\n * @constructor\n *\n * @example\n *\n * <caption>Creating a plug-in that logs whenever a shape is added to the canvas.</caption>\n *\n * // plug-in implemenentation\n * function MyLoggingPlugin(eventBus) {\n *   eventBus.on('shape.added', function(event) {\n *     console.log('shape ', event.shape, ' was added to the diagram');\n *   });\n * }\n *\n * // export as module\n * export default {\n *   __init__: [ 'myLoggingPlugin' ],\n *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]\n * };\n *\n *\n * // instantiate the diagram with the new plug-in\n *\n * import MyLoggingModule from 'path-to-my-logging-plugin';\n *\n * var diagram = new Diagram({\n *   modules: [\n *     MyLoggingModule\n *   ]\n * });\n *\n * diagram.invoke([ 'canvas', function(canvas) {\n *   // add shape to drawing canvas\n *   canvas.addShape({ x: 10, y: 10 });\n * });\n *\n * // 'shape ... was added to the diagram' logged to console\n *\n * @param {Object} options\n * @param {Array<didi.Module>} [options.modules] external modules to instantiate with the diagram\n * @param {didi.Injector} [injector] an (optional) injector to bootstrap the diagram with\n */\nexport default function Diagram(options, injector) {\n\n  // create injector unless explicitly specified\n  this.injector = injector = injector || createInjector(options);\n\n  // API\n\n  /**\n   * Resolves a diagram service\n   *\n   * @method Diagram#get\n   *\n   * @param {string} name the name of the diagram service to be retrieved\n   * @param {boolean} [strict=true] if false, resolve missing services to null\n   */\n  this.get = injector.get;\n\n  /**\n   * Executes a function into which diagram services are injected\n   *\n   * @method Diagram#invoke\n   *\n   * @param {Function|Object[]} fn the function to resolve\n   * @param {Object} locals a number of locals to use to resolve certain dependencies\n   */\n  this.invoke = injector.invoke;\n\n  // init\n\n  // indicate via event\n\n\n  /**\n   * An event indicating that all plug-ins are loaded.\n   *\n   * Use this event to fire other events to interested plug-ins\n   *\n   * @memberOf Diagram\n   *\n   * @event diagram.init\n   *\n   * @example\n   *\n   * eventBus.on('diagram.init', function() {\n   *   eventBus.fire('my-custom-event', { foo: 'BAR' });\n   * });\n   *\n   * @type {Object}\n   */\n  this.get('eventBus').fire('diagram.init');\n}\n\n\n/**\n * Destroys the diagram\n *\n * @method  Diagram#destroy\n */\nDiagram.prototype.destroy = function() {\n  this.get('eventBus').fire('diagram.destroy');\n};\n\n/**\n * Clear the diagram, removing all contents.\n */\nDiagram.prototype.clear = function() {\n  this.get('eventBus').fire('diagram.clear');\n};\n","import {\n  isNumber,\n  assign,\n  forEach,\n  every,\n  debounce,\n  bind,\n  reduce\n} from 'min-dash';\n\nimport {\n  add as collectionAdd,\n  remove as collectionRemove\n} from '../util/Collections';\n\nimport {\n  getType,\n  getBBox as getBoundingBox\n} from '../util/Elements';\n\nimport { asTRBL } from '../layout/LayoutUtil';\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  classes as svgClasses,\n  create as svgCreate,\n  transform as svgTransform\n} from 'tiny-svg';\n\nimport { createMatrix as createMatrix } from 'tiny-svg';\n\n\nfunction round(number, resolution) {\n  return Math.round(number * resolution) / resolution;\n}\n\nfunction ensurePx(number) {\n  return isNumber(number) ? number + 'px' : number;\n}\n\n/**\n * Creates a HTML container element for a SVG element with\n * the given configuration\n *\n * @param  {Object} options\n * @return {HTMLElement} the container element\n */\nfunction createContainer(options) {\n\n  options = assign({}, { width: '100%', height: '100%' }, options);\n\n  var container = options.container || document.body;\n\n  // create a <div> around the svg element with the respective size\n  // this way we can always get the correct container size\n  // (this is impossible for <svg> elements at the moment)\n  var parent = document.createElement('div');\n  parent.setAttribute('class', 'djs-container');\n\n  assign(parent.style, {\n    position: 'relative',\n    overflow: 'hidden',\n    width: ensurePx(options.width),\n    height: ensurePx(options.height)\n  });\n\n  container.appendChild(parent);\n\n  return parent;\n}\n\nfunction createGroup(parent, cls, childIndex) {\n  var group = svgCreate('g');\n  svgClasses(group).add(cls);\n\n  var index = childIndex !== undefined ? childIndex : parent.childNodes.length - 1;\n\n  // must ensure second argument is node or _null_\n  // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n  parent.insertBefore(group, parent.childNodes[index] || null);\n\n  return group;\n}\n\nvar BASE_LAYER = 'base';\n\n\nvar REQUIRED_MODEL_ATTRS = {\n  shape: [ 'x', 'y', 'width', 'height' ],\n  connection: [ 'waypoints' ]\n};\n\n/**\n * The main drawing canvas.\n *\n * @class\n * @constructor\n *\n * @emits Canvas#canvas.init\n *\n * @param {Object} config\n * @param {EventBus} eventBus\n * @param {GraphicsFactory} graphicsFactory\n * @param {ElementRegistry} elementRegistry\n */\nexport default function Canvas(config, eventBus, graphicsFactory, elementRegistry) {\n\n  this._eventBus = eventBus;\n  this._elementRegistry = elementRegistry;\n  this._graphicsFactory = graphicsFactory;\n\n  this._init(config || {});\n}\n\nCanvas.$inject = [\n  'config.canvas',\n  'eventBus',\n  'graphicsFactory',\n  'elementRegistry'\n];\n\n\nCanvas.prototype._init = function(config) {\n\n  var eventBus = this._eventBus;\n\n  // Creates a <svg> element that is wrapped into a <div>.\n  // This way we are always able to correctly figure out the size of the svg element\n  // by querying the parent node.\n  //\n  // (It is not possible to get the size of a svg element cross browser @ 2014-04-01)\n  //\n  // <div class=\"djs-container\" style=\"width: {desired-width}, height: {desired-height}\">\n  //   <svg width=\"100%\" height=\"100%\">\n  //    ...\n  //   </svg>\n  // </div>\n\n  // html container\n  var container = this._container = createContainer(config);\n\n  var svg = this._svg = svgCreate('svg');\n  svgAttr(svg, { width: '100%', height: '100%' });\n\n  svgAppend(container, svg);\n\n  var viewport = this._viewport = createGroup(svg, 'viewport');\n\n  this._layers = {};\n\n  // debounce canvas.viewbox.changed events\n  // for smoother diagram interaction\n  if (config.deferUpdate !== false) {\n    this._viewboxChanged = debounce(bind(this._viewboxChanged, this), 300);\n  }\n\n  eventBus.on('diagram.init', function() {\n\n    /**\n     * An event indicating that the canvas is ready to be drawn on.\n     *\n     * @memberOf Canvas\n     *\n     * @event canvas.init\n     *\n     * @type {Object}\n     * @property {SVGElement} svg the created svg element\n     * @property {SVGElement} viewport the direct parent of diagram elements and shapes\n     */\n    eventBus.fire('canvas.init', {\n      svg: svg,\n      viewport: viewport\n    });\n\n  }, this);\n\n  // reset viewbox on shape changes to\n  // recompute the viewbox\n  eventBus.on([\n    'shape.added',\n    'connection.added',\n    'shape.removed',\n    'connection.removed',\n    'elements.changed'\n  ], function() {\n    delete this._cachedViewbox;\n  }, this);\n\n  eventBus.on('diagram.destroy', 500, this._destroy, this);\n  eventBus.on('diagram.clear', 500, this._clear, this);\n};\n\nCanvas.prototype._destroy = function(emit) {\n  this._eventBus.fire('canvas.destroy', {\n    svg: this._svg,\n    viewport: this._viewport\n  });\n\n  var parent = this._container.parentNode;\n\n  if (parent) {\n    parent.removeChild(this._container);\n  }\n\n  delete this._svg;\n  delete this._container;\n  delete this._layers;\n  delete this._rootElement;\n  delete this._viewport;\n};\n\nCanvas.prototype._clear = function() {\n\n  var self = this;\n\n  var allElements = this._elementRegistry.getAll();\n\n  // remove all elements\n  allElements.forEach(function(element) {\n    var type = getType(element);\n\n    if (type === 'root') {\n      self.setRootElement(null, true);\n    } else {\n      self._removeElement(element, type);\n    }\n  });\n\n  // force recomputation of view box\n  delete this._cachedViewbox;\n};\n\n/**\n * Returns the default layer on which\n * all elements are drawn.\n *\n * @returns {SVGElement}\n */\nCanvas.prototype.getDefaultLayer = function() {\n  return this.getLayer(BASE_LAYER, 0);\n};\n\n/**\n * Returns a layer that is used to draw elements\n * or annotations on it.\n *\n * Non-existing layers retrieved through this method\n * will be created. During creation, the optional index\n * may be used to create layers below or above existing layers.\n * A layer with a certain index is always created above all\n * existing layers with the same index.\n *\n * @param {string} name\n * @param {number} index\n *\n * @returns {SVGElement}\n */\nCanvas.prototype.getLayer = function(name, index) {\n\n  if (!name) {\n    throw new Error('must specify a name');\n  }\n\n  var layer = this._layers[name];\n\n  if (!layer) {\n    layer = this._layers[name] = this._createLayer(name, index);\n  }\n\n  // throw an error if layer creation / retrival is\n  // requested on different index\n  if (typeof index !== 'undefined' && layer.index !== index) {\n    throw new Error('layer <' + name + '> already created at index <' + index + '>');\n  }\n\n  return layer.group;\n};\n\n/**\n * Creates a given layer and returns it.\n *\n * @param {string} name\n * @param {number} [index=0]\n *\n * @return {Object} layer descriptor with { index, group: SVGGroup }\n */\nCanvas.prototype._createLayer = function(name, index) {\n\n  if (!index) {\n    index = 0;\n  }\n\n  var childIndex = reduce(this._layers, function(childIndex, layer) {\n    if (index >= layer.index) {\n      childIndex++;\n    }\n\n    return childIndex;\n  }, 0);\n\n  return {\n    group: createGroup(this._viewport, 'layer-' + name, childIndex),\n    index: index\n  };\n\n};\n\n/**\n * Returns the html element that encloses the\n * drawing canvas.\n *\n * @return {DOMNode}\n */\nCanvas.prototype.getContainer = function() {\n  return this._container;\n};\n\n\n// markers //////////////////////\n\nCanvas.prototype._updateMarker = function(element, marker, add) {\n  var container;\n\n  if (!element.id) {\n    element = this._elementRegistry.get(element);\n  }\n\n  // we need to access all\n  container = this._elementRegistry._elements[element.id];\n\n  if (!container) {\n    return;\n  }\n\n  forEach([ container.gfx, container.secondaryGfx ], function(gfx) {\n    if (gfx) {\n\n      // invoke either addClass or removeClass based on mode\n      if (add) {\n        svgClasses(gfx).add(marker);\n      } else {\n        svgClasses(gfx).remove(marker);\n      }\n    }\n  });\n\n  /**\n   * An event indicating that a marker has been updated for an element\n   *\n   * @event element.marker.update\n   * @type {Object}\n   * @property {djs.model.Element} element the shape\n   * @property {Object} gfx the graphical representation of the shape\n   * @property {string} marker\n   * @property {boolean} add true if the marker was added, false if it got removed\n   */\n  this._eventBus.fire('element.marker.update', { element: element, gfx: container.gfx, marker: marker, add: !!add });\n};\n\n\n/**\n * Adds a marker to an element (basically a css class).\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @example\n * canvas.addMarker('foo', 'some-marker');\n *\n * var fooGfx = canvas.getGraphics('foo');\n *\n * fooGfx; // <g class=\"... some-marker\"> ... </g>\n *\n * @param {string|djs.model.Base} element\n * @param {string} marker\n */\nCanvas.prototype.addMarker = function(element, marker) {\n  this._updateMarker(element, marker, true);\n};\n\n\n/**\n * Remove a marker from an element.\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @param  {string|djs.model.Base} element\n * @param  {string} marker\n */\nCanvas.prototype.removeMarker = function(element, marker) {\n  this._updateMarker(element, marker, false);\n};\n\n/**\n * Check the existence of a marker on element.\n *\n * @param  {string|djs.model.Base} element\n * @param  {string} marker\n */\nCanvas.prototype.hasMarker = function(element, marker) {\n  if (!element.id) {\n    element = this._elementRegistry.get(element);\n  }\n\n  var gfx = this.getGraphics(element);\n\n  return svgClasses(gfx).has(marker);\n};\n\n/**\n * Toggles a marker on an element.\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @param  {string|djs.model.Base} element\n * @param  {string} marker\n */\nCanvas.prototype.toggleMarker = function(element, marker) {\n  if (this.hasMarker(element, marker)) {\n    this.removeMarker(element, marker);\n  } else {\n    this.addMarker(element, marker);\n  }\n};\n\nCanvas.prototype.getRootElement = function() {\n  if (!this._rootElement) {\n    this.setRootElement({ id: '__implicitroot', children: [] });\n  }\n\n  return this._rootElement;\n};\n\n\n\n// root element handling //////////////////////\n\n/**\n * Sets a given element as the new root element for the canvas\n * and returns the new root element.\n *\n * @param {Object|djs.model.Root} element\n * @param {boolean} [override] whether to override the current root element, if any\n *\n * @return {Object|djs.model.Root} new root element\n */\nCanvas.prototype.setRootElement = function(element, override) {\n\n  if (element) {\n    this._ensureValid('root', element);\n  }\n\n  var currentRoot = this._rootElement,\n      elementRegistry = this._elementRegistry,\n      eventBus = this._eventBus;\n\n  if (currentRoot) {\n    if (!override) {\n      throw new Error('rootElement already set, need to specify override');\n    }\n\n    // simulate element remove event sequence\n    eventBus.fire('root.remove', { element: currentRoot });\n    eventBus.fire('root.removed', { element: currentRoot });\n\n    elementRegistry.remove(currentRoot);\n  }\n\n  if (element) {\n    var gfx = this.getDefaultLayer();\n\n    // resemble element add event sequence\n    eventBus.fire('root.add', { element: element });\n\n    elementRegistry.add(element, gfx, this._svg);\n\n    eventBus.fire('root.added', { element: element, gfx: gfx });\n  }\n\n  this._rootElement = element;\n\n  return element;\n};\n\n\n\n// add functionality //////////////////////\n\nCanvas.prototype._ensureValid = function(type, element) {\n  if (!element.id) {\n    throw new Error('element must have an id');\n  }\n\n  if (this._elementRegistry.get(element.id)) {\n    throw new Error('element with id ' + element.id + ' already exists');\n  }\n\n  var requiredAttrs = REQUIRED_MODEL_ATTRS[type];\n\n  var valid = every(requiredAttrs, function(attr) {\n    return typeof element[attr] !== 'undefined';\n  });\n\n  if (!valid) {\n    throw new Error(\n      'must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);\n  }\n};\n\nCanvas.prototype._setParent = function(element, parent, parentIndex) {\n  collectionAdd(parent.children, element, parentIndex);\n  element.parent = parent;\n};\n\n/**\n * Adds an element to the canvas.\n *\n * This wires the parent <-> child relationship between the element and\n * a explicitly specified parent or an implicit root element.\n *\n * During add it emits the events\n *\n *  * <{type}.add> (element, parent)\n *  * <{type}.added> (element, gfx)\n *\n * Extensions may hook into these events to perform their magic.\n *\n * @param {string} type\n * @param {Object|djs.model.Base} element\n * @param {Object|djs.model.Base} [parent]\n * @param {number} [parentIndex]\n *\n * @return {Object|djs.model.Base} the added element\n */\nCanvas.prototype._addElement = function(type, element, parent, parentIndex) {\n\n  parent = parent || this.getRootElement();\n\n  var eventBus = this._eventBus,\n      graphicsFactory = this._graphicsFactory;\n\n  this._ensureValid(type, element);\n\n  eventBus.fire(type + '.add', { element: element, parent: parent });\n\n  this._setParent(element, parent, parentIndex);\n\n  // create graphics\n  var gfx = graphicsFactory.create(type, element, parentIndex);\n\n  this._elementRegistry.add(element, gfx);\n\n  // update its visual\n  graphicsFactory.update(type, element, gfx);\n\n  eventBus.fire(type + '.added', { element: element, gfx: gfx });\n\n  return element;\n};\n\n/**\n * Adds a shape to the canvas\n *\n * @param {Object|djs.model.Shape} shape to add to the diagram\n * @param {djs.model.Base} [parent]\n * @param {number} [parentIndex]\n *\n * @return {djs.model.Shape} the added shape\n */\nCanvas.prototype.addShape = function(shape, parent, parentIndex) {\n  return this._addElement('shape', shape, parent, parentIndex);\n};\n\n/**\n * Adds a connection to the canvas\n *\n * @param {Object|djs.model.Connection} connection to add to the diagram\n * @param {djs.model.Base} [parent]\n * @param {number} [parentIndex]\n *\n * @return {djs.model.Connection} the added connection\n */\nCanvas.prototype.addConnection = function(connection, parent, parentIndex) {\n  return this._addElement('connection', connection, parent, parentIndex);\n};\n\n\n/**\n * Internal remove element\n */\nCanvas.prototype._removeElement = function(element, type) {\n\n  var elementRegistry = this._elementRegistry,\n      graphicsFactory = this._graphicsFactory,\n      eventBus = this._eventBus;\n\n  element = elementRegistry.get(element.id || element);\n\n  if (!element) {\n\n    // element was removed already\n    return;\n  }\n\n  eventBus.fire(type + '.remove', { element: element });\n\n  graphicsFactory.remove(element);\n\n  // unset parent <-> child relationship\n  collectionRemove(element.parent && element.parent.children, element);\n  element.parent = null;\n\n  eventBus.fire(type + '.removed', { element: element });\n\n  elementRegistry.remove(element);\n\n  return element;\n};\n\n\n/**\n * Removes a shape from the canvas\n *\n * @param {string|djs.model.Shape} shape or shape id to be removed\n *\n * @return {djs.model.Shape} the removed shape\n */\nCanvas.prototype.removeShape = function(shape) {\n\n  /**\n   * An event indicating that a shape is about to be removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event shape.remove\n   * @type {Object}\n   * @property {djs.model.Shape} element the shape descriptor\n   * @property {Object} gfx the graphical representation of the shape\n   */\n\n  /**\n   * An event indicating that a shape has been removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event shape.removed\n   * @type {Object}\n   * @property {djs.model.Shape} element the shape descriptor\n   * @property {Object} gfx the graphical representation of the shape\n   */\n  return this._removeElement(shape, 'shape');\n};\n\n\n/**\n * Removes a connection from the canvas\n *\n * @param {string|djs.model.Connection} connection or connection id to be removed\n *\n * @return {djs.model.Connection} the removed connection\n */\nCanvas.prototype.removeConnection = function(connection) {\n\n  /**\n   * An event indicating that a connection is about to be removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event connection.remove\n   * @type {Object}\n   * @property {djs.model.Connection} element the connection descriptor\n   * @property {Object} gfx the graphical representation of the connection\n   */\n\n  /**\n   * An event indicating that a connection has been removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event connection.removed\n   * @type {Object}\n   * @property {djs.model.Connection} element the connection descriptor\n   * @property {Object} gfx the graphical representation of the connection\n   */\n  return this._removeElement(connection, 'connection');\n};\n\n\n/**\n * Return the graphical object underlaying a certain diagram element\n *\n * @param {string|djs.model.Base} element descriptor of the element\n * @param {boolean} [secondary=false] whether to return the secondary connected element\n *\n * @return {SVGElement}\n */\nCanvas.prototype.getGraphics = function(element, secondary) {\n  return this._elementRegistry.getGraphics(element, secondary);\n};\n\n\n/**\n * Perform a viewbox update via a given change function.\n *\n * @param {Function} changeFn\n */\nCanvas.prototype._changeViewbox = function(changeFn) {\n\n  // notify others of the upcoming viewbox change\n  this._eventBus.fire('canvas.viewbox.changing');\n\n  // perform actual change\n  changeFn.apply(this);\n\n  // reset the cached viewbox so that\n  // a new get operation on viewbox or zoom\n  // triggers a viewbox re-computation\n  this._cachedViewbox = null;\n\n  // notify others of the change; this step\n  // may or may not be debounced\n  this._viewboxChanged();\n};\n\nCanvas.prototype._viewboxChanged = function() {\n  this._eventBus.fire('canvas.viewbox.changed', { viewbox: this.viewbox() });\n};\n\n\n/**\n * Gets or sets the view box of the canvas, i.e. the\n * area that is currently displayed.\n *\n * The getter may return a cached viewbox (if it is currently\n * changing). To force a recomputation, pass `false` as the first argument.\n *\n * @example\n *\n * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })\n *\n * // sets the visible area of the diagram to (100|100) -> (600|100)\n * // and and scales it according to the diagram width\n *\n * var viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.\n *\n * console.log(viewbox);\n * // {\n * //   inner: Dimensions,\n * //   outer: Dimensions,\n * //   scale,\n * //   x, y,\n * //   width, height\n * // }\n *\n * // if the current diagram is zoomed and scrolled, you may reset it to the\n * // default zoom via this method, too:\n *\n * var zoomedAndScrolledViewbox = canvas.viewbox();\n *\n * canvas.viewbox({\n *   x: 0,\n *   y: 0,\n *   width: zoomedAndScrolledViewbox.outer.width,\n *   height: zoomedAndScrolledViewbox.outer.height\n * });\n *\n * @param  {Object} [box] the new view box to set\n * @param  {number} box.x the top left X coordinate of the canvas visible in view box\n * @param  {number} box.y the top left Y coordinate of the canvas visible in view box\n * @param  {number} box.width the visible width\n * @param  {number} box.height\n *\n * @return {Object} the current view box\n */\nCanvas.prototype.viewbox = function(box) {\n\n  if (box === undefined && this._cachedViewbox) {\n    return this._cachedViewbox;\n  }\n\n  var viewport = this._viewport,\n      innerBox,\n      outerBox = this.getSize(),\n      matrix,\n      transform,\n      scale,\n      x, y;\n\n  if (!box) {\n\n    // compute the inner box based on the\n    // diagrams default layer. This allows us to exclude\n    // external components, such as overlays\n    innerBox = this.getDefaultLayer().getBBox();\n\n    transform = svgTransform(viewport);\n    matrix = transform ? transform.matrix : createMatrix();\n    scale = round(matrix.a, 1000);\n\n    x = round(-matrix.e || 0, 1000);\n    y = round(-matrix.f || 0, 1000);\n\n    box = this._cachedViewbox = {\n      x: x ? x / scale : 0,\n      y: y ? y / scale : 0,\n      width: outerBox.width / scale,\n      height: outerBox.height / scale,\n      scale: scale,\n      inner: {\n        width: innerBox.width,\n        height: innerBox.height,\n        x: innerBox.x,\n        y: innerBox.y\n      },\n      outer: outerBox\n    };\n\n    return box;\n  } else {\n\n    this._changeViewbox(function() {\n      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);\n\n      var matrix = this._svg.createSVGMatrix()\n        .scale(scale)\n        .translate(-box.x, -box.y);\n\n      svgTransform(viewport, matrix);\n    });\n  }\n\n  return box;\n};\n\n\n/**\n * Gets or sets the scroll of the canvas.\n *\n * @param {Object} [delta] the new scroll to apply.\n *\n * @param {number} [delta.dx]\n * @param {number} [delta.dy]\n */\nCanvas.prototype.scroll = function(delta) {\n\n  var node = this._viewport;\n  var matrix = node.getCTM();\n\n  if (delta) {\n    this._changeViewbox(function() {\n      delta = assign({ dx: 0, dy: 0 }, delta || {});\n\n      matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);\n\n      setCTM(node, matrix);\n    });\n  }\n\n  return { x: matrix.e, y: matrix.f };\n};\n\n/**\n * Scrolls the viewbox to contain the given element.\n * Optionally specify a padding to be applied to the edges.\n *\n * @param {Object} [element] the element to scroll to.\n * @param {Object|Number} [padding=100] the padding to be applied. Can also specify top, bottom, left and right.\n *\n */\nCanvas.prototype.scrollToElement = function(element, padding) {\n  var defaultPadding = 100;\n  if (!padding) {\n    padding = {};\n  }\n  if (typeof padding === 'number') {\n    defaultPadding = padding;\n  }\n\n  padding = {\n    top: padding.top || defaultPadding,\n    right: padding.right || defaultPadding,\n    bottom: padding.bottom || defaultPadding,\n    left: padding.left || defaultPadding\n  };\n\n  var elementBounds = getBoundingBox(element),\n      elementTrbl = asTRBL(elementBounds),\n      viewboxBounds = this.viewbox(),\n      zoom = this.zoom(),\n      dx, dy;\n\n  // Shrink viewboxBounds with padding\n  viewboxBounds.y += padding.top / zoom;\n  viewboxBounds.x += padding.left / zoom;\n  viewboxBounds.width -= (padding.right + padding.left) / zoom;\n  viewboxBounds.height -= (padding.bottom + padding.top) / zoom;\n\n  var viewboxTrbl = asTRBL(viewboxBounds);\n\n  var canFit = elementBounds.width < viewboxBounds.width && elementBounds.height < viewboxBounds.height;\n\n  if (!canFit) {\n\n    // top-left when element can't fit\n    dx = elementBounds.x - viewboxBounds.x;\n    dy = elementBounds.y - viewboxBounds.y;\n\n  } else {\n\n    var dRight = Math.max(0, elementTrbl.right - viewboxTrbl.right),\n        dLeft = Math.min(0, elementTrbl.left - viewboxTrbl.left),\n        dBottom = Math.max(0, elementTrbl.bottom - viewboxTrbl.bottom),\n        dTop = Math.min(0, elementTrbl.top - viewboxTrbl.top);\n\n    dx = dRight || dLeft;\n    dy = dBottom || dTop;\n\n  }\n\n  this.scroll({ dx: -dx * zoom, dy: -dy * zoom });\n};\n\n/**\n * Gets or sets the current zoom of the canvas, optionally zooming\n * to the specified position.\n *\n * The getter may return a cached zoom level. Call it with `false` as\n * the first argument to force recomputation of the current level.\n *\n * @param {string|number} [newScale] the new zoom level, either a number, i.e. 0.9,\n *                                   or `fit-viewport` to adjust the size to fit the current viewport\n * @param {string|Point} [center] the reference point { x: .., y: ..} to zoom to, 'auto' to zoom into mid or null\n *\n * @return {number} the current scale\n */\nCanvas.prototype.zoom = function(newScale, center) {\n\n  if (!newScale) {\n    return this.viewbox(newScale).scale;\n  }\n\n  if (newScale === 'fit-viewport') {\n    return this._fitViewport(center);\n  }\n\n  var outer,\n      matrix;\n\n  this._changeViewbox(function() {\n\n    if (typeof center !== 'object') {\n      outer = this.viewbox().outer;\n\n      center = {\n        x: outer.width / 2,\n        y: outer.height / 2\n      };\n    }\n\n    matrix = this._setZoom(newScale, center);\n  });\n\n  return round(matrix.a, 1000);\n};\n\nfunction setCTM(node, m) {\n  var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';\n  node.setAttribute('transform', mstr);\n}\n\nCanvas.prototype._fitViewport = function(center) {\n\n  var vbox = this.viewbox(),\n      outer = vbox.outer,\n      inner = vbox.inner,\n      newScale,\n      newViewbox;\n\n  // display the complete diagram without zooming in.\n  // instead of relying on internal zoom, we perform a\n  // hard reset on the canvas viewbox to realize this\n  //\n  // if diagram does not need to be zoomed in, we focus it around\n  // the diagram origin instead\n\n  if (inner.x >= 0 &&\n      inner.y >= 0 &&\n      inner.x + inner.width <= outer.width &&\n      inner.y + inner.height <= outer.height &&\n      !center) {\n\n    newViewbox = {\n      x: 0,\n      y: 0,\n      width: Math.max(inner.width + inner.x, outer.width),\n      height: Math.max(inner.height + inner.y, outer.height)\n    };\n  } else {\n\n    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);\n    newViewbox = {\n      x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),\n      y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),\n      width: outer.width / newScale,\n      height: outer.height / newScale\n    };\n  }\n\n  this.viewbox(newViewbox);\n\n  return this.viewbox(false).scale;\n};\n\n\nCanvas.prototype._setZoom = function(scale, center) {\n\n  var svg = this._svg,\n      viewport = this._viewport;\n\n  var matrix = svg.createSVGMatrix();\n  var point = svg.createSVGPoint();\n\n  var centerPoint,\n      originalPoint,\n      currentMatrix,\n      scaleMatrix,\n      newMatrix;\n\n  currentMatrix = viewport.getCTM();\n\n  var currentScale = currentMatrix.a;\n\n  if (center) {\n    centerPoint = assign(point, center);\n\n    // revert applied viewport transformations\n    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());\n\n    // create scale matrix\n    scaleMatrix = matrix\n      .translate(originalPoint.x, originalPoint.y)\n      .scale(1 / currentScale * scale)\n      .translate(-originalPoint.x, -originalPoint.y);\n\n    newMatrix = currentMatrix.multiply(scaleMatrix);\n  } else {\n    newMatrix = matrix.scale(scale);\n  }\n\n  setCTM(this._viewport, newMatrix);\n\n  return newMatrix;\n};\n\n\n/**\n * Returns the size of the canvas\n *\n * @return {Dimensions}\n */\nCanvas.prototype.getSize = function() {\n  return {\n    width: this._container.clientWidth,\n    height: this._container.clientHeight\n  };\n};\n\n\n/**\n * Return the absolute bounding box for the given element\n *\n * The absolute bounding box may be used to display overlays in the\n * callers (browser) coordinate system rather than the zoomed in/out\n * canvas coordinates.\n *\n * @param  {ElementDescriptor} element\n * @return {Bounds} the absolute bounding box\n */\nCanvas.prototype.getAbsoluteBBox = function(element) {\n  var vbox = this.viewbox();\n  var bbox;\n\n  // connection\n  // use svg bbox\n  if (element.waypoints) {\n    var gfx = this.getGraphics(element);\n\n    bbox = gfx.getBBox();\n  }\n\n  // shapes\n  // use data\n  else {\n    bbox = element;\n  }\n\n  var x = bbox.x * vbox.scale - vbox.x * vbox.scale;\n  var y = bbox.y * vbox.scale - vbox.y * vbox.scale;\n\n  var width = bbox.width * vbox.scale;\n  var height = bbox.height * vbox.scale;\n\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n};\n\n/**\n * Fires an event in order other modules can react to the\n * canvas resizing\n */\nCanvas.prototype.resized = function() {\n\n  // force recomputation of view box\n  delete this._cachedViewbox;\n\n  this._eventBus.fire('canvas.resized');\n};\n","var ELEMENT_ID = 'data-element-id';\n\nimport { attr as svgAttr } from 'tiny-svg';\n\n\n/**\n * @class\n *\n * A registry that keeps track of all shapes in the diagram.\n */\nexport default function ElementRegistry(eventBus) {\n  this._elements = {};\n\n  this._eventBus = eventBus;\n}\n\nElementRegistry.$inject = [ 'eventBus' ];\n\n/**\n * Register a pair of (element, gfx, (secondaryGfx)).\n *\n * @param {djs.model.Base} element\n * @param {SVGElement} gfx\n * @param {SVGElement} [secondaryGfx] optional other element to register, too\n */\nElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {\n\n  var id = element.id;\n\n  this._validateId(id);\n\n  // associate dom node with element\n  svgAttr(gfx, ELEMENT_ID, id);\n\n  if (secondaryGfx) {\n    svgAttr(secondaryGfx, ELEMENT_ID, id);\n  }\n\n  this._elements[id] = { element: element, gfx: gfx, secondaryGfx: secondaryGfx };\n};\n\n/**\n * Removes an element from the registry.\n *\n * @param {djs.model.Base} element\n */\nElementRegistry.prototype.remove = function(element) {\n  var elements = this._elements,\n      id = element.id || element,\n      container = id && elements[id];\n\n  if (container) {\n\n    // unset element id on gfx\n    svgAttr(container.gfx, ELEMENT_ID, '');\n\n    if (container.secondaryGfx) {\n      svgAttr(container.secondaryGfx, ELEMENT_ID, '');\n    }\n\n    delete elements[id];\n  }\n};\n\n/**\n * Update the id of an element\n *\n * @param {djs.model.Base} element\n * @param {string} newId\n */\nElementRegistry.prototype.updateId = function(element, newId) {\n\n  this._validateId(newId);\n\n  if (typeof element === 'string') {\n    element = this.get(element);\n  }\n\n  this._eventBus.fire('element.updateId', {\n    element: element,\n    newId: newId\n  });\n\n  var gfx = this.getGraphics(element),\n      secondaryGfx = this.getGraphics(element, true);\n\n  this.remove(element);\n\n  element.id = newId;\n\n  this.add(element, gfx, secondaryGfx);\n};\n\n/**\n * Return the model element for a given id or graphics.\n *\n * @example\n *\n * elementRegistry.get('SomeElementId_1');\n * elementRegistry.get(gfx);\n *\n *\n * @param {string|SVGElement} filter for selecting the element\n *\n * @return {djs.model.Base}\n */\nElementRegistry.prototype.get = function(filter) {\n  var id;\n\n  if (typeof filter === 'string') {\n    id = filter;\n  } else {\n    id = filter && svgAttr(filter, ELEMENT_ID);\n  }\n\n  var container = this._elements[id];\n  return container && container.element;\n};\n\n/**\n * Return all elements that match a given filter function.\n *\n * @param {Function} fn\n *\n * @return {Array<djs.model.Base>}\n */\nElementRegistry.prototype.filter = function(fn) {\n\n  var filtered = [];\n\n  this.forEach(function(element, gfx) {\n    if (fn(element, gfx)) {\n      filtered.push(element);\n    }\n  });\n\n  return filtered;\n};\n\n/**\n * Return the first element that satisfies the provided testing function.\n *\n * @param {Function} fn\n *\n * @return {djs.model.Base}\n */\nElementRegistry.prototype.find = function(fn) {\n  var map = this._elements,\n      keys = Object.keys(map);\n\n  for (var i = 0; i < keys.length; i++) {\n    var id = keys[i],\n        container = map[id],\n        element = container.element,\n        gfx = container.gfx;\n\n    if (fn(element, gfx)) {\n      return element;\n    }\n  }\n};\n\n/**\n * Return all rendered model elements.\n *\n * @return {Array<djs.model.Base>}\n */\nElementRegistry.prototype.getAll = function() {\n  return this.filter(function(e) { return e; });\n};\n\n/**\n * Iterate over all diagram elements.\n *\n * @param {Function} fn\n */\nElementRegistry.prototype.forEach = function(fn) {\n\n  var map = this._elements;\n\n  Object.keys(map).forEach(function(id) {\n    var container = map[id],\n        element = container.element,\n        gfx = container.gfx;\n\n    return fn(element, gfx);\n  });\n};\n\n/**\n * Return the graphical representation of an element or its id.\n *\n * @example\n * elementRegistry.getGraphics('SomeElementId_1');\n * elementRegistry.getGraphics(rootElement); // <g ...>\n *\n * elementRegistry.getGraphics(rootElement, true); // <svg ...>\n *\n *\n * @param {string|djs.model.Base} filter\n * @param {boolean} [secondary=false] whether to return the secondary connected element\n *\n * @return {SVGElement}\n */\nElementRegistry.prototype.getGraphics = function(filter, secondary) {\n  var id = filter.id || filter;\n\n  var container = this._elements[id];\n  return container && (secondary ? container.secondaryGfx : container.gfx);\n};\n\n/**\n * Validate the suitability of the given id and signals a problem\n * with an exception.\n *\n * @param {string} id\n *\n * @throws {Error} if id is empty or already assigned\n */\nElementRegistry.prototype._validateId = function(id) {\n  if (!id) {\n    throw new Error('element must have an id');\n  }\n\n  if (this._elements[id]) {\n    throw new Error('element with id ' + id + ' already added');\n  }\n};\n","import {\n  isFunction,\n  isArray,\n  isNumber,\n  bind,\n  assign\n} from 'min-dash';\n\nvar FN_REF = '__fn';\n\nvar DEFAULT_PRIORITY = 1000;\n\nvar slice = Array.prototype.slice;\n\n/**\n * A general purpose event bus.\n *\n * This component is used to communicate across a diagram instance.\n * Other parts of a diagram can use it to listen to and broadcast events.\n *\n *\n * ## Registering for Events\n *\n * The event bus provides the {@link EventBus#on} and {@link EventBus#once}\n * methods to register for events. {@link EventBus#off} can be used to\n * remove event registrations. Listeners receive an instance of {@link Event}\n * as the first argument. It allows them to hook into the event execution.\n *\n * ```javascript\n *\n * // listen for event\n * eventBus.on('foo', function(event) {\n *\n *   // access event type\n *   event.type; // 'foo'\n *\n *   // stop propagation to other listeners\n *   event.stopPropagation();\n *\n *   // prevent event default\n *   event.preventDefault();\n * });\n *\n * // listen for event with custom payload\n * eventBus.on('bar', function(event, payload) {\n *   console.log(payload);\n * });\n *\n * // listen for event returning value\n * eventBus.on('foobar', function(event) {\n *\n *   // stop event propagation + prevent default\n *   return false;\n *\n *   // stop event propagation + return custom result\n *   return {\n *     complex: 'listening result'\n *   };\n * });\n *\n *\n * // listen with custom priority (default=1000, higher is better)\n * eventBus.on('priorityfoo', 1500, function(event) {\n *   console.log('invoked first!');\n * });\n *\n *\n * // listen for event and pass the context (`this`)\n * eventBus.on('foobar', function(event) {\n *   this.foo();\n * }, this);\n * ```\n *\n *\n * ## Emitting Events\n *\n * Events can be emitted via the event bus using {@link EventBus#fire}.\n *\n * ```javascript\n *\n * // false indicates that the default action\n * // was prevented by listeners\n * if (eventBus.fire('foo') === false) {\n *   console.log('default has been prevented!');\n * };\n *\n *\n * // custom args + return value listener\n * eventBus.on('sum', function(event, a, b) {\n *   return a + b;\n * });\n *\n * // you can pass custom arguments + retrieve result values.\n * var sum = eventBus.fire('sum', 1, 2);\n * console.log(sum); // 3\n * ```\n */\nexport default function EventBus() {\n  this._listeners = {};\n\n  // cleanup on destroy on lowest priority to allow\n  // message passing until the bitter end\n  this.on('diagram.destroy', 1, this._destroy, this);\n}\n\n\n/**\n * Register an event listener for events with the given name.\n *\n * The callback will be invoked with `event, ...additionalArguments`\n * that have been passed to {@link EventBus#fire}.\n *\n * Returning false from a listener will prevent the events default action\n * (if any is specified). To stop an event from being processed further in\n * other listeners execute {@link Event#stopPropagation}.\n *\n * Returning anything but `undefined` from a listener will stop the listener propagation.\n *\n * @param {string|Array<string>} events\n * @param {number} [priority=1000] the priority in which this listener is called, larger is higher\n * @param {Function} callback\n * @param {Object} [that] Pass context (`this`) to the callback\n */\nEventBus.prototype.on = function(events, priority, callback, that) {\n\n  events = isArray(events) ? events : [ events ];\n\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n\n  var actualCallback = callback;\n\n  if (that) {\n    actualCallback = bind(callback, that);\n\n    // make sure we remember and are able to remove\n    // bound callbacks via {@link #off} using the original\n    // callback\n    actualCallback[FN_REF] = callback[FN_REF] || callback;\n  }\n\n  var self = this;\n\n  events.forEach(function(e) {\n    self._addListener(e, {\n      priority: priority,\n      callback: actualCallback,\n      next: null\n    });\n  });\n};\n\n\n/**\n * Register an event listener that is executed only once.\n *\n * @param {string} event the event name to register for\n * @param {number} [priority=1000] the priority in which this listener is called, larger is higher\n * @param {Function} callback the callback to execute\n * @param {Object} [that] Pass context (`this`) to the callback\n */\nEventBus.prototype.once = function(event, priority, callback, that) {\n  var self = this;\n\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n\n  function wrappedCallback() {\n    wrappedCallback.__isTomb = true;\n\n    var result = callback.apply(that, arguments);\n\n    self.off(event, wrappedCallback);\n\n    return result;\n  }\n\n  // make sure we remember and are able to remove\n  // bound callbacks via {@link #off} using the original\n  // callback\n  wrappedCallback[FN_REF] = callback;\n\n  this.on(event, priority, wrappedCallback);\n};\n\n\n/**\n * Removes event listeners by event and callback.\n *\n * If no callback is given, all listeners for a given event name are being removed.\n *\n * @param {string|Array<string>} events\n * @param {Function} [callback]\n */\nEventBus.prototype.off = function(events, callback) {\n\n  events = isArray(events) ? events : [ events ];\n\n  var self = this;\n\n  events.forEach(function(event) {\n    self._removeListener(event, callback);\n  });\n\n};\n\n\n/**\n * Create an EventBus event.\n *\n * @param {Object} data\n *\n * @return {Object} event, recognized by the eventBus\n */\nEventBus.prototype.createEvent = function(data) {\n  var event = new InternalEvent();\n\n  event.init(data);\n\n  return event;\n};\n\n\n/**\n * Fires a named event.\n *\n * @example\n *\n * // fire event by name\n * events.fire('foo');\n *\n * // fire event object with nested type\n * var event = { type: 'foo' };\n * events.fire(event);\n *\n * // fire event with explicit type\n * var event = { x: 10, y: 20 };\n * events.fire('element.moved', event);\n *\n * // pass additional arguments to the event\n * events.on('foo', function(event, bar) {\n *   alert(bar);\n * });\n *\n * events.fire({ type: 'foo' }, 'I am bar!');\n *\n * @param {string} [name] the optional event name\n * @param {Object} [event] the event object\n * @param {...Object} additional arguments to be passed to the callback functions\n *\n * @return {boolean} the events return value, if specified or false if the\n *                   default action was prevented by listeners\n */\nEventBus.prototype.fire = function(type, data) {\n  var event,\n      firstListener,\n      returnValue,\n      args;\n\n  args = slice.call(arguments);\n\n  if (typeof type === 'object') {\n    data = type;\n    type = data.type;\n  }\n\n  if (!type) {\n    throw new Error('no event type specified');\n  }\n\n  firstListener = this._listeners[type];\n\n  if (!firstListener) {\n    return;\n  }\n\n  // we make sure we fire instances of our home made\n  // events here. We wrap them only once, though\n  if (data instanceof InternalEvent) {\n\n    // we are fine, we alread have an event\n    event = data;\n  } else {\n    event = this.createEvent(data);\n  }\n\n  // ensure we pass the event as the first parameter\n  args[0] = event;\n\n  // original event type (in case we delegate)\n  var originalType = event.type;\n\n  // update event type before delegation\n  if (type !== originalType) {\n    event.type = type;\n  }\n\n  try {\n    returnValue = this._invokeListeners(event, args, firstListener);\n  } finally {\n\n    // reset event type after delegation\n    if (type !== originalType) {\n      event.type = originalType;\n    }\n  }\n\n  // set the return value to false if the event default\n  // got prevented and no other return value exists\n  if (returnValue === undefined && event.defaultPrevented) {\n    returnValue = false;\n  }\n\n  return returnValue;\n};\n\n\nEventBus.prototype.handleError = function(error) {\n  return this.fire('error', { error: error }) === false;\n};\n\n\nEventBus.prototype._destroy = function() {\n  this._listeners = {};\n};\n\nEventBus.prototype._invokeListeners = function(event, args, listener) {\n\n  var returnValue;\n\n  while (listener) {\n\n    // handle stopped propagation\n    if (event.cancelBubble) {\n      break;\n    }\n\n    returnValue = this._invokeListener(event, args, listener);\n\n    listener = listener.next;\n  }\n\n  return returnValue;\n};\n\nEventBus.prototype._invokeListener = function(event, args, listener) {\n\n  var returnValue;\n\n  if (listener.callback.__isTomb) {\n    return returnValue;\n  }\n\n  try {\n\n    // returning false prevents the default action\n    returnValue = invokeFunction(listener.callback, args);\n\n    // stop propagation on return value\n    if (returnValue !== undefined) {\n      event.returnValue = returnValue;\n      event.stopPropagation();\n    }\n\n    // prevent default on return false\n    if (returnValue === false) {\n      event.preventDefault();\n    }\n  } catch (e) {\n    if (!this.handleError(e)) {\n      console.error('unhandled error in event listener');\n      console.error(e.stack);\n\n      throw e;\n    }\n  }\n\n  return returnValue;\n};\n\n/*\n * Add new listener with a certain priority to the list\n * of listeners (for the given event).\n *\n * The semantics of listener registration / listener execution are\n * first register, first serve: New listeners will always be inserted\n * after existing listeners with the same priority.\n *\n * Example: Inserting two listeners with priority 1000 and 1300\n *\n *    * before: [ 1500, 1500, 1000, 1000 ]\n *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]\n *\n * @param {string} event\n * @param {Object} listener { priority, callback }\n */\nEventBus.prototype._addListener = function(event, newListener) {\n\n  var listener = this._getListeners(event),\n      previousListener;\n\n  // no prior listeners\n  if (!listener) {\n    this._setListeners(event, newListener);\n\n    return;\n  }\n\n  // ensure we order listeners by priority from\n  // 0 (high) to n > 0 (low)\n  while (listener) {\n\n    if (listener.priority < newListener.priority) {\n\n      newListener.next = listener;\n\n      if (previousListener) {\n        previousListener.next = newListener;\n      } else {\n        this._setListeners(event, newListener);\n      }\n\n      return;\n    }\n\n    previousListener = listener;\n    listener = listener.next;\n  }\n\n  // add new listener to back\n  previousListener.next = newListener;\n};\n\n\nEventBus.prototype._getListeners = function(name) {\n  return this._listeners[name];\n};\n\nEventBus.prototype._setListeners = function(name, listener) {\n  this._listeners[name] = listener;\n};\n\nEventBus.prototype._removeListener = function(event, callback) {\n\n  var listener = this._getListeners(event),\n      nextListener,\n      previousListener,\n      listenerCallback;\n\n  if (!callback) {\n\n    // clear listeners\n    this._setListeners(event, null);\n\n    return;\n  }\n\n  while (listener) {\n\n    nextListener = listener.next;\n\n    listenerCallback = listener.callback;\n\n    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {\n      if (previousListener) {\n        previousListener.next = nextListener;\n      } else {\n\n        // new first listener\n        this._setListeners(event, nextListener);\n      }\n    }\n\n    previousListener = listener;\n    listener = nextListener;\n  }\n};\n\n/**\n * A event that is emitted via the event bus.\n */\nfunction InternalEvent() { }\n\nInternalEvent.prototype.stopPropagation = function() {\n  this.cancelBubble = true;\n};\n\nInternalEvent.prototype.preventDefault = function() {\n  this.defaultPrevented = true;\n};\n\nInternalEvent.prototype.init = function(data) {\n  assign(this, data || {});\n};\n\n\n/**\n * Invoke function. Be fast...\n *\n * @param {Function} fn\n * @param {Array<Object>} args\n *\n * @return {Any}\n */\nfunction invokeFunction(fn, args) {\n  return fn.apply(null, args);\n}\n","import {\n  forEach,\n  reduce\n} from 'min-dash';\n\nimport {\n  getChildren,\n  getVisual\n} from '../util/GraphicsUtil';\n\nimport { translate } from '../util/SvgTransformUtil';\n\nimport { clear as domClear } from 'min-dom';\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  classes as svgClasses,\n  create as svgCreate,\n  remove as svgRemove\n} from 'tiny-svg';\n\nimport {\n  isFrameElement\n} from '../util/Elements';\n\n/**\n * A factory that creates graphical elements\n *\n * @param {EventBus} eventBus\n * @param {ElementRegistry} elementRegistry\n */\nexport default function GraphicsFactory(eventBus, elementRegistry) {\n  this._eventBus = eventBus;\n  this._elementRegistry = elementRegistry;\n}\n\nGraphicsFactory.$inject = [ 'eventBus' , 'elementRegistry' ];\n\n\nGraphicsFactory.prototype._getChildrenContainer = function(element) {\n\n  var gfx = this._elementRegistry.getGraphics(element);\n\n  var childrenGfx;\n\n  // root element\n  if (!element.parent) {\n    childrenGfx = gfx;\n  } else {\n    childrenGfx = getChildren(gfx);\n    if (!childrenGfx) {\n      childrenGfx = svgCreate('g');\n      svgClasses(childrenGfx).add('djs-children');\n\n      svgAppend(gfx.parentNode, childrenGfx);\n    }\n  }\n\n  return childrenGfx;\n};\n\n/**\n * Clears the graphical representation of the element and returns the\n * cleared visual (the <g class=\"djs-visual\" /> element).\n */\nGraphicsFactory.prototype._clear = function(gfx) {\n  var visual = getVisual(gfx);\n\n  domClear(visual);\n\n  return visual;\n};\n\n/**\n * Creates a gfx container for shapes and connections\n *\n * The layout is as follows:\n *\n * <g class=\"djs-group\">\n *\n *   <!-- the gfx -->\n *   <g class=\"djs-element djs-(shape|connection|frame)\">\n *     <g class=\"djs-visual\">\n *       <!-- the renderer draws in here -->\n *     </g>\n *\n *     <!-- extensions (overlays, click box, ...) goes here\n *   </g>\n *\n *   <!-- the gfx child nodes -->\n *   <g class=\"djs-children\"></g>\n * </g>\n *\n * @param {string} type the type of the element, i.e. shape | connection\n * @param {SVGElement} [childrenGfx]\n * @param {number} [parentIndex] position to create container in parent\n * @param {boolean} [isFrame] is frame element\n *\n * @return {SVGElement}\n */\nGraphicsFactory.prototype._createContainer = function(\n    type, childrenGfx, parentIndex, isFrame\n) {\n  var outerGfx = svgCreate('g');\n  svgClasses(outerGfx).add('djs-group');\n\n  // insert node at position\n  if (typeof parentIndex !== 'undefined') {\n    prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);\n  } else {\n    svgAppend(childrenGfx, outerGfx);\n  }\n\n  var gfx = svgCreate('g');\n  svgClasses(gfx).add('djs-element');\n  svgClasses(gfx).add('djs-' + type);\n\n  if (isFrame) {\n    svgClasses(gfx).add('djs-frame');\n  }\n\n  svgAppend(outerGfx, gfx);\n\n  // create visual\n  var visual = svgCreate('g');\n  svgClasses(visual).add('djs-visual');\n\n  svgAppend(gfx, visual);\n\n  return gfx;\n};\n\nGraphicsFactory.prototype.create = function(type, element, parentIndex) {\n  var childrenGfx = this._getChildrenContainer(element.parent);\n  return this._createContainer(type, childrenGfx, parentIndex, isFrameElement(element));\n};\n\nGraphicsFactory.prototype.updateContainments = function(elements) {\n\n  var self = this,\n      elementRegistry = this._elementRegistry,\n      parents;\n\n  parents = reduce(elements, function(map, e) {\n\n    if (e.parent) {\n      map[e.parent.id] = e.parent;\n    }\n\n    return map;\n  }, {});\n\n  // update all parents of changed and reorganized their children\n  // in the correct order (as indicated in our model)\n  forEach(parents, function(parent) {\n\n    var children = parent.children;\n\n    if (!children) {\n      return;\n    }\n\n    var childrenGfx = self._getChildrenContainer(parent);\n\n    forEach(children.slice().reverse(), function(child) {\n      var childGfx = elementRegistry.getGraphics(child);\n\n      prependTo(childGfx.parentNode, childrenGfx);\n    });\n  });\n};\n\nGraphicsFactory.prototype.drawShape = function(visual, element) {\n  var eventBus = this._eventBus;\n\n  return eventBus.fire('render.shape', { gfx: visual, element: element });\n};\n\nGraphicsFactory.prototype.getShapePath = function(element) {\n  var eventBus = this._eventBus;\n\n  return eventBus.fire('render.getShapePath', element);\n};\n\nGraphicsFactory.prototype.drawConnection = function(visual, element) {\n  var eventBus = this._eventBus;\n\n  return eventBus.fire('render.connection', { gfx: visual, element: element });\n};\n\nGraphicsFactory.prototype.getConnectionPath = function(waypoints) {\n  var eventBus = this._eventBus;\n\n  return eventBus.fire('render.getConnectionPath', waypoints);\n};\n\nGraphicsFactory.prototype.update = function(type, element, gfx) {\n\n  // do NOT update root element\n  if (!element.parent) {\n    return;\n  }\n\n  var visual = this._clear(gfx);\n\n  // redraw\n  if (type === 'shape') {\n    this.drawShape(visual, element);\n\n    // update positioning\n    translate(gfx, element.x, element.y);\n  } else\n  if (type === 'connection') {\n    this.drawConnection(visual, element);\n  } else {\n    throw new Error('unknown type: ' + type);\n  }\n\n  if (element.hidden) {\n    svgAttr(gfx, 'display', 'none');\n  } else {\n    svgAttr(gfx, 'display', 'block');\n  }\n};\n\nGraphicsFactory.prototype.remove = function(element) {\n  var gfx = this._elementRegistry.getGraphics(element);\n\n  // remove\n  svgRemove(gfx.parentNode);\n};\n\n\n// helpers //////////\n\nfunction prependTo(newNode, parentNode, siblingNode) {\n  var node = siblingNode || parentNode.firstChild;\n\n  // do not prepend node to itself to prevent IE from crashing\n  // https://github.com/bpmn-io/bpmn-js/issues/746\n  if (newNode === node) {\n    return;\n  }\n\n  parentNode.insertBefore(newNode, node);\n}\n","import DrawModule from '../draw';\n\nimport Canvas from './Canvas';\nimport ElementRegistry from './ElementRegistry';\nimport ElementFactory from './ElementFactory';\nimport EventBus from './EventBus';\nimport GraphicsFactory from './GraphicsFactory';\n\nexport default {\n  __depends__: [ DrawModule ],\n  __init__: [ 'canvas' ],\n  canvas: [ 'type', Canvas ],\n  elementRegistry: [ 'type', ElementRegistry ],\n  elementFactory: [ 'type', ElementFactory ],\n  eventBus: [ 'type', EventBus ],\n  graphicsFactory: [ 'type', GraphicsFactory ]\n};","import inherits from 'inherits';\n\nimport BaseRenderer from './BaseRenderer';\n\nimport {\n  componentsToPath,\n  createLine\n} from '../util/RenderUtil';\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  create as svgCreate\n} from 'tiny-svg';\n\nimport {\n  isFrameElement\n} from '../util/Elements';\n\n// apply default renderer with lowest possible priority\n// so that it only kicks in if noone else could render\nvar DEFAULT_RENDER_PRIORITY = 1;\n\n/**\n * The default renderer used for shapes and connections.\n *\n * @param {EventBus} eventBus\n * @param {Styles} styles\n */\nexport default function DefaultRenderer(eventBus, styles) {\n\n  //\n  BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY);\n\n  this.CONNECTION_STYLE = styles.style([ 'no-fill' ], { strokeWidth: 5, stroke: 'fuchsia' });\n  this.SHAPE_STYLE = styles.style({ fill: 'white', stroke: 'fuchsia', strokeWidth: 2 });\n  this.FRAME_STYLE = styles.style([ 'no-fill' ], { stroke: 'fuchsia', strokeDasharray: 4, strokeWidth: 2 });\n}\n\ninherits(DefaultRenderer, BaseRenderer);\n\n\nDefaultRenderer.prototype.canRender = function() {\n  return true;\n};\n\nDefaultRenderer.prototype.drawShape = function drawShape(visuals, element) {\n  var rect = svgCreate('rect');\n\n  svgAttr(rect, {\n    x: 0,\n    y: 0,\n    width: element.width || 0,\n    height: element.height || 0\n  });\n\n  if (isFrameElement(element)) {\n    svgAttr(rect, this.FRAME_STYLE);\n  } else {\n    svgAttr(rect, this.SHAPE_STYLE);\n  }\n\n  svgAppend(visuals, rect);\n\n  return rect;\n};\n\nDefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection) {\n\n  var line = createLine(connection.waypoints, this.CONNECTION_STYLE);\n  svgAppend(visuals, line);\n\n  return line;\n};\n\nDefaultRenderer.prototype.getShapePath = function getShapePath(shape) {\n\n  var x = shape.x,\n      y = shape.y,\n      width = shape.width,\n      height = shape.height;\n\n  var shapePath = [\n    ['M', x, y],\n    ['l', width, 0],\n    ['l', 0, height],\n    ['l', -width, 0],\n    ['z']\n  ];\n\n  return componentsToPath(shapePath);\n};\n\nDefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {\n  var waypoints = connection.waypoints;\n\n  var idx, point, connectionPath = [];\n\n  for (idx = 0; (point = waypoints[idx]); idx++) {\n\n    // take invisible docking into account\n    // when creating the path\n    point = point.original || point;\n\n    connectionPath.push([ idx === 0 ? 'M' : 'L', point.x, point.y ]);\n  }\n\n  return componentsToPath(connectionPath);\n};\n\n\nDefaultRenderer.$inject = [ 'eventBus', 'styles' ];\n","import {\n  isArray,\n  assign,\n  reduce\n} from 'min-dash';\n\n\n/**\n * A component that manages shape styles\n */\nexport default function Styles() {\n\n  var defaultTraits = {\n\n    'no-fill': {\n      fill: 'none'\n    },\n    'no-border': {\n      strokeOpacity: 0.0\n    },\n    'no-events': {\n      pointerEvents: 'none'\n    }\n  };\n\n  var self = this;\n\n  /**\n   * Builds a style definition from a className, a list of traits and an object of additional attributes.\n   *\n   * @param  {string} className\n   * @param  {Array<string>} traits\n   * @param  {Object} additionalAttrs\n   *\n   * @return {Object} the style defintion\n   */\n  this.cls = function(className, traits, additionalAttrs) {\n    var attrs = this.style(traits, additionalAttrs);\n\n    return assign(attrs, { 'class': className });\n  };\n\n  /**\n   * Builds a style definition from a list of traits and an object of additional attributes.\n   *\n   * @param  {Array<string>} traits\n   * @param  {Object} additionalAttrs\n   *\n   * @return {Object} the style defintion\n   */\n  this.style = function(traits, additionalAttrs) {\n\n    if (!isArray(traits) && !additionalAttrs) {\n      additionalAttrs = traits;\n      traits = [];\n    }\n\n    var attrs = reduce(traits, function(attrs, t) {\n      return assign(attrs, defaultTraits[t] || {});\n    }, {});\n\n    return additionalAttrs ? assign(attrs, additionalAttrs) : attrs;\n  };\n\n  this.computeStyle = function(custom, traits, defaultStyles) {\n    if (!isArray(traits)) {\n      defaultStyles = traits;\n      traits = [];\n    }\n\n    return self.style(traits || [], assign({}, defaultStyles, custom || {}));\n  };\n}\n","import DefaultRenderer from './DefaultRenderer';\nimport Styles from './Styles';\n\nexport default {\n  __init__: [ 'defaultRenderer' ],\n  defaultRenderer: [ 'type', DefaultRenderer ],\n  styles: [ 'type', Styles ]\n};\n","var CLASS_PATTERN = /^class /;\n\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction annotate() {\n  var args = Array.prototype.slice.call(arguments);\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  var fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n}\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nvar CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARGS = /^(?:async )?(?:function\\s*)?[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\nfunction parseAnnotations(fn) {\n\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n\n  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n\n  return match[1] && match[1].split(',').map(function(arg) {\n    match = arg.match(FN_ARG);\n    return match ? match[1].trim() : arg.trim();\n  }) || [];\n}\n\nfunction Module() {\n  var providers = [];\n\n  this.factory = function(name, factory) {\n    providers.push([name, 'factory', factory]);\n    return this;\n  };\n\n  this.value = function(name, value) {\n    providers.push([name, 'value', value]);\n    return this;\n  };\n\n  this.type = function(name, type) {\n    providers.push([name, 'type', type]);\n    return this;\n  };\n\n  this.forEach = function(iterator) {\n    providers.forEach(iterator);\n  };\n\n}\n\nfunction Injector(modules, parent) {\n  parent = parent || {\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n\n  var self = instances.injector = this;\n\n  var error = function(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {String} name\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {Object}\n   */\n  var get = function(name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  };\n\n  var fnDef = function(fn, locals) {\n\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n\n    var inject = fn.$inject || parseAnnotations(fn);\n    var dependencies = inject.map(function(dep) {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n\n    return {\n      fn: fn,\n      dependencies: dependencies\n    };\n  };\n\n  var instantiate = function(Type) {\n    var def = fnDef(Type);\n\n    var fn = def.fn,\n        dependencies = def.dependencies;\n\n    // instantiate var args constructor\n    var Constructor = Function.prototype.bind.apply(fn, [ null ].concat(dependencies));\n\n    return new Constructor();\n  };\n\n  var invoke = function(func, context, locals) {\n    var def = fnDef(func, locals);\n\n    var fn = def.fn,\n        dependencies = def.dependencies;\n\n    return fn.apply(context, dependencies);\n  };\n\n\n  var createPrivateInjectorFactory = function(privateChildInjector) {\n    return annotate(function(key) {\n      return privateChildInjector.get(key);\n    });\n  };\n\n  var createChild = function(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n      for (var name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(function(scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(function(scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  modules.forEach(function(module) {\n\n    function arrayUnwrap(type, value) {\n      if (type !== 'value' && isArray(value)) {\n        value = annotate(value.slice());\n      }\n\n      return value;\n    }\n\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function(provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n\n        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n      });\n    } else if (typeof module === 'object') {\n      if (module.__exports__) {\n        var clonedModule = Object.keys(module).reduce(function(m, key) {\n          if (key.substring(0, 2) !== '__') {\n            m[key] = module[key];\n          }\n          return m;\n        }, Object.create(null));\n\n        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);\n        var getFromPrivateInjector = annotate(function(key) {\n          return privateInjector.get(key);\n        });\n        module.__exports__.forEach(function(key) {\n          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n        });\n      } else {\n        Object.keys(module).forEach(function(name) {\n          if (module[name][2] === 'private') {\n            providers[name] = module[name];\n            return;\n          }\n\n          var type = module[name][0];\n          var value = module[name][1];\n\n          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n        });\n      }\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n}\n\nexport { annotate, parseAnnotations, Module, Injector };\n"],"names":[],"sourceRoot":""}